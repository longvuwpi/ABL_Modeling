package abl.generated;
// the package corresponds to where generated Java files are placed.

import abl.wmes.CreepWME;
import abl.wmes.PlayerWME;
import abl.actions.*;
import abl.sensors.*;
import java.awt.Point;
// Imports are used the same way as in Java. Its necessary to import Sensor, Action, and WME classes.
/** 
 * A simple agent that moves towards the player and occasionally fires bullets.
 *
 * @author Ben Weber 3-7-11
 */ 
behaving_entity ChaserAgent {
// This defines a name for the agent 

	/** 
	 * Define the physicals actions that the agent can perform. The definition includes an action prototype and
	 * and an action class name. The class name must be a Java class which has been imported. 
	 *
	 * The prototype parameters correspond to the types expected by the execute(object[]) method 
	 * in the action's Java class.
	 */
	register act moveUp(int) with MoveUp;
	register act moveDown(int) with MoveDown; 
	register act moveLeft(int) with MoveLeft;
	register act moveRight(int) with MoveRight;
	register act stop(int) with Stop;
        register act stopHorizontal(int) with StopHorizontal;
        register act stopVertical(int) with StopVertical;
	register act fire(int, int) with Fire;

	/**
	 * Define the sensors that add game state to working memory. Each sensor defines the name of the WME class
	 * that it is responsible for managing and the Java sensor class that implements the functionality. 
	 */
    register wme PlayerWME with PlayerSensor;
    register wme CreepWME with CreepSensor;

	/**
	 * Defines a variable scope to the agent, which can be used and modified in behaviors. 
	 *
	 * It is also possible to use constants from a Java interface (e.g.):
     * constants game.Constants;   
	 */ 
	int ChaserSpeed = 2;
	int threshold_distance = 3;
	Point targetDestPoint;
	double distance;

	/**
	 * After an initial delay, continuously fire bullets. 
	 */
	atomic sequential behavior manageFiring() {
		//subgoal Wait(2000);					// this suspends the execution of the behavior


		with (persistent) subgoal fire();
	}

    /**
     * Fires a bullet at the player character using the chaser position at the source and the player position as the target
     *
     * Each fire action is followed by a cooldown period. 
     */
	sequential behavior fire() {
		//precondition {
		//	(PlayerWME locationX::playerX locationY::playerY)	// locationX invokes PlayerMWE.getLocationX() 
		//	(ChaserWME locationX::chaserX locationY::chaserY)   // :: is used to bind properties to behavior scoped variables
		//}

                precondition {
                    (PlayerWME isInRangeOfCreep::creepInRange)
                    (PlayerWME creep_object_id::creepID)
                    (PlayerWME player_object_id::playerID)
                    (creepInRange == true) 
                }

                specificity 1;

		mental_act {
			System.out.println("Firing");
		}

		act fire(playerID,creepID);	
		//subgoal Wait(500);
	}

        sequential behavior fire() {
                precondition {
                    (PlayerWME isInRangeOfCreep::creepInRange)
                    (creepInRange == false) 
                }
                specificity 2;

                mental_act {
                    System.out.println("Creep not in range, not firing");
                }
        }

        sequential behavior fire() {
                precondition {
                    (PlayerWME creep_exists::creepExists)
                    (creepExists == false) 
                }
                specificity 2;

                mental_act {
                    System.out.println("Creep does not exist, not firing");
                }
        }


        sequential behavior creep_fire() {
            precondition {
                (CreepWME is_dead::creep_dead)
                (CreepWME is_aggroed::creep_aggroed)
                (creep_dead == false)
                (creep_aggroed == false)
            }
            
		mental_act {
			System.out.println("Creep idle");
		}

            //specificity 3;

        }

        sequential behavior creep_fire() {
            precondition {
                (CreepWME is_dead::creep_dead)
                (creep_dead == true)
            }
            
		mental_act {
			System.out.println("Creep dead, not firing anymore");
		}

            //specificity 3;

            fail_step;
        }

        sequential behavior creep_fire() {
            precondition {
                (CreepWME is_aggroed::creep_aggroed)
                (CreepWME creep_object_id::creepid)
                (CreepWME attacker_object_id::attackerid)
                (creep_aggroed == true)
            }
           // specificity 2;

		mental_act {
			System.out.println("Creep aggroed, firing");
		}

            act fire(creepid,attackerid);

        }
	/**
	 * Continuously move towards the player character.
	 */
	atomic sequential behavior manageMovement() {
		with (persistent) subgoal move();
	}

	sequential behavior move() {
		precondition {
                        (PlayerWME isInRangeOfCreep::creepInRange)
                    (PlayerWME creep_exists::creepExists)
                    (PlayerWME player_object_id::playerID)
                    (creepExists == true) 
                        (creepInRange == true) 
		}
		specificity 3;
		
		mental_act {
			System.out.println("Stopping");
		}
 
		act stop(playerID);
	}

        sequential behavior move() {
                precondition {
                    (PlayerWME creep_exists::creepExists)
                    (PlayerWME player_object_id::playerID)
                    (creepExists == false) 
                }
                specificity 3;

                mental_act {
                    System.out.println("Creep does not exist, not moving");
                }

                act stop(playerID);
        }

	sequential behavior move() {
		precondition {
			(PlayerWME player_location_y::playerY)
                        (PlayerWME player_trajectory_dy::playerDy)
                        (PlayerWME player_object_id::playerID)
			(PlayerWME creep_location_y::creepY)
                        (PlayerWME isInRangeOfCreep::creepInRange)
                        (creepInRange == false) 
			(creepY > (playerY - playerDy))
                        (creepY < (playerY + playerDy))
		}
		specificity 3;
		
		mental_act {
			System.out.println("stop vertical");
		}
 
		act stopVertical(playerID);
	}

	sequential behavior move() {
		precondition {
			(PlayerWME player_location_x::playerX)
                        (PlayerWME player_trajectory_dx::playerDx)
                        (PlayerWME player_object_id::playerID)
			(PlayerWME creep_location_x::creepX) 
                        (PlayerWME isInRangeOfCreep::creepInRange)
                        (creepInRange == false)
			(creepX > (playerX - playerDx))
                        (creepX < (playerX + playerDx))
		}
		specificity 3;
		
		mental_act {
			System.out.println("stop horizontal");
		}

		act stopHorizontal(playerID);
	}

	/**
	 * Moves the chaser up if the player is above the chaser.
	 * 
	 * Note: The agent prefers vertical over horizonal movement, because the move up and move down behaviors have 
	 * a higher specificity than the other move behaviors. Therefore, if the agent needs to be moved up or down,
	 * they are chosen first. 
	 */ 
	sequential behavior move() {
		precondition {
			(PlayerWME player_location_y::playerY)
                        (PlayerWME player_trajectory_dy::playerDy)
                        (PlayerWME player_object_id::playerID)
			(PlayerWME creep_location_y::creepY)
                        (PlayerWME isInRangeOfCreep::creepInRange)
                        (creepInRange == false) 
			(creepY <= (playerY - playerDy))
		}
		specificity 2;
		
		mental_act {
			System.out.println("Moving up");
		}
 
		act moveUp(playerID);
	}
 	
	/**
	 * Moves the chaser down if the player is below the chaser.
	 */
	sequential behavior move() {
		precondition {
			(PlayerWME player_location_y::playerY)
                        (PlayerWME player_trajectory_dy::playerDy)
                        (PlayerWME player_object_id::playerID)
			(PlayerWME creep_location_y::creepY)
                        (PlayerWME isInRangeOfCreep::creepInRange)
                        (creepInRange == false)
			(creepY >= (playerY + playerDy))
		}
		specificity 2;
		
		mental_act {
			System.out.println("Moving down");
		}

		act moveDown(playerID);
	}
 	 
	/**
	 * Moves the chaser left if the player to the left of the chaser.
	 */
	sequential behavior move() {
		precondition {
			(PlayerWME player_location_x::playerX)
                        (PlayerWME player_trajectory_dx::playerDx)
                        (PlayerWME player_object_id::playerID)
			(PlayerWME creep_location_x::creepX) 
                        (PlayerWME isInRangeOfCreep::creepInRange)
                        (creepInRange == false)
			(creepX <= (playerX - playerDx))
		}
		specificity 2;
		
		mental_act {
			System.out.println("Moving left");
		}

		act moveLeft(playerID);
	}

	/**
	 * Moves the chaser right if the player to the right of the chaser.
	 */
	sequential behavior move() {
		precondition { 
			(PlayerWME player_location_x::playerX)
                        (PlayerWME player_trajectory_dx::playerDx)
                        (PlayerWME player_object_id::playerID)
			(PlayerWME creep_location_x::creepX) 
                        (PlayerWME isInRangeOfCreep::creepInRange)
                        (creepInRange == false)
			(creepX >= (playerX + playerDx))
		}
		specificity 2;
		
		mental_act {
			System.out.println("Moving right");
		}

		act moveRight(playerID);
	}
	
	/**
	 * Stops the chaser.
	 *
	 * Of the move behaviors, this is always evaluated last due to having the lowest specificity. 
	 * Since it is evaluated last, it is only reached if none of the other behaviors can be activited,
	 * which means the player and chaser are overlapping. This is why there are no preconditions. 
	 */
	/*sequential behavior move() {
		specificity 1;
		
		mental_act {
			//System.out.println("In stop");
		}
		
		act stop();
	}*/

	

    /**
     * Utility behavior for suspending the execution of a behavior.
     *
     * This behavior consist of two steps. First, the mental act compute the finishing time
     * based on the input delay. Second, the success tests waits until the condition check
     * evaluates to true.
     */
	sequential behavior Wait(int milliseconds) {
		long finish;
	    mental_act { 
	    	finish = System.currentTimeMillis() + milliseconds; 
	    }
	    
	    with ( success_test { (System.currentTimeMillis() > finish) } ) wait;
	}
 
        parallel behavior player_behavior() {
            subgoal manageFiring();
            subgoal manageMovement();
        }

        atomic sequential behavior creep_behavior() {
             with (persistent when_succeeds) subgoal creep_fire();
        }

        sequential behavior beginAction() {
            subgoal fire();
            subgoal move();
            subgoal creep_fire();

        }
    /** 
     * Root of the active behavior tree.
     *
     * Note: this is a parallel behavior.
     * Note: the ABL compiler expects this to be the last behavior defined in the agent. 
     * Note: prioirities are used to ensure all goals are pursued, since the move() goal can thrash in this simple example
     */
    initial_tree {
    	mental_act {
			System.out.println("Starting Chaser Agent");
    	}

        //subgoal beginAction();
        with (persistent) subgoal beginAction();
    }
}
